pragma solidity ^0.4.11;

import "../controller/Reputation.sol";
import "./IntVoteInterface.sol";

// ToDo: Write tests!

contract AbsoluteVote is IntVoteInterface{
  using SafeMath for uint;


  struct Parameters {
      Reputation reputationSystem; // the reputation system that is being used
      uint precReq; // how many precentages are required for the porpsal to be passed
      bool allowOwner; // does this porposal has a owner who has owner rights?
  }

  struct Voter {
      int vote; // voter's vote: 1 - 'yes', -1 - 'no', 0 - 'abstain'
      uint reputation; // amount of voter's reputation
  }

  struct Proposal {
      address owner; // the porposal's owner
      address avatar; // the avatar of the organization that owns the porposal
      ExecutableInterface executable; // will be executed if the perposal will pass
      bytes32 paramsHash; // the hash of the parameters of the porposal
      uint yes; // total 'yes' votes
      uint no; // total 'no' votes
      uint abstain; // total 'abstain' votes
      mapping(address=>Voter) voters;
      bool opened; // voting opened flag
      bool executed; // voting was executed flag
  }

  event LogNewProposal(bytes32 indexed _proposalId, address _proposer, bytes32 _paramsHash);
  event LogCancelProposal(bytes32 indexed _proposalId);
  event LogExecuteProposal(bytes32 indexed _proposalId, int _decision);
  event LogVoteProposal(bytes32 indexed _proposalId, address indexed _voter, int _vote, uint _reputation, bool _isOwnerVote);
  event LogCancelVoting(bytes32 indexed _proposalId, address indexed _voter);

  mapping(bytes32=>Parameters) public parameters;  // A mapping from hashes to parameters
  mapping(bytes32=>Proposal) public proposals; // Mapping from the ID of the proposal to the proposal itself.

  uint proposalsCnt; // Total amount of porposals

  /**
   * @dev Check that there is owner for the porposal and he sent the transaction
   */
  modifier onlyOwner(bytes32 _proposalId) {
    require(msg.sender == proposals[_proposalId].owner);
    _;
  }

  /**
   * @dev Check that the porposal is votable (opened and not executed yet)
   */
  modifier votableProposal(bytes32 _proposalId) {
    require(proposals[_proposalId].opened);
    require(! proposals[_proposalId].executed);
    _;
  }

  function AbsoluteVote() {
  }

  /**
   * @dev hash the parameters, save them if necessary, and return the hash value
   */
  function setParameters(Reputation _reputationSystem, uint _precReq, bool _allowOwner) returns(bytes32) {
    require(_precReq <= 100);
    bytes32 hashedParameters = getParametersHash(_reputationSystem, _precReq, _allowOwner);
    parameters[hashedParameters] = Parameters({
      precReq: _precReq,
      reputationSystem: _reputationSystem,
      allowOwner: _allowOwner
    });
    return hashedParameters;
  }

  /**
   * @dev hashParameters returns a hash of the given parameters
   */
  function getParametersHash(Reputation _reputationSystem, uint _precReq, bool _allowOwner) constant returns(bytes32) {
      return sha3(_reputationSystem, _precReq, _allowOwner);
  }

  /**
   * @dev register a new proposal with the given parameters. Every porposal has a unique ID which is being
   * generated by calculating sha3 of a incremented counter.
   * @param _paramsHash defined the parameters of the voting machine used for this proposal
   * @param _avatar an address to be sent as the payload to the _executable contract.
   * @param _executable This contract will be executed when vote is over.
   */
  function propose(bytes32 _paramsHash, address _avatar, ExecutableInterface _executable) returns(bytes32) {
    // Check params exist:
    require(parameters[_paramsHash].reputationSystem != address(0));

    // Generate a unique ID:
    bytes32 proposalId = sha3(this, proposalsCnt);
    proposalsCnt++;

    // Open proposal:
    Proposal memory proposal;
    proposal.paramsHash = _paramsHash;
    proposal.avatar = _avatar;
    proposal.executable = _executable;
    proposal.owner = msg.sender;
    proposal.opened = true;
    proposals[proposalId] = proposal;
    LogNewProposal(proposalId, msg.sender, _paramsHash);
    return proposalId;
  }

  /**
   * @dev Cancel a porposal, only the owner can call this function and only if allowOwner flag is true.
   * @param _proposalId the porposal ID
   */
  function cancelProposal(bytes32 _proposalId) onlyOwner(_proposalId) returns(bool){
    if (! parameters[proposals[_proposalId].paramsHash].allowOwner) {
      return false;
    }
    delete proposals[_proposalId];
    LogCancelProposal(_proposalId);
    return true;
  }

  /**
   * @dev Vote for a proposal, if the voter already voted, cancel the last vote and set a new one instead
   * @param _proposalId id of the proposal
   * @param _vote yes (1) / no (-1) / abstain (0)
   * @param _voter used in case the vote is cast for someone else
   * @return true in case of success
   * throws if proposal is not opened or if it is executed
   * NB: executes the proposal if a decision has been reached
   */
  function internalVote(bytes32 _proposalId, int _vote, address _voter) internal votableProposal(_proposalId) {
    Proposal storage proposal = proposals[_proposalId];

    // Check valid vote:
    require(_vote == 1 || _vote == -1 || _vote == 0);

    // If this voter has already voted, first cancel the vote:
    if (proposal.voters[_voter].reputation != 0) {
        cancelVote(_proposalId);
    }

    // The voting itself:
    uint reputation = parameters[proposal.paramsHash].reputationSystem.reputationOf(_voter);
    if (_vote == 1) {
      proposal.yes = reputation.add(proposal.yes);
    }
    if (_vote == -1) {
      proposal.no = reputation.add(proposal.no);
    }
    if (_vote == 0) {
      proposal.abstain = reputation.add(proposal.abstain);
    }
    proposal.voters[_voter] = Voter({
      reputation: reputation,
      vote: _vote
    });

    // Check if ownerVote:
    bool isOwnerVote;
    if (_voter != msg.sender) {
      isOwnerVote = true;
    }

    // Event:
    LogVoteProposal(_proposalId, _voter, _vote, reputation, isOwnerVote);

    // execute the proposal if this vote was decisive:
    executeProposal(_proposalId);
  }

  /**
   * @dev voting function
   * @param _proposalId id of the proposal
   * @param _vote yes (1) / no (-1) / abstain (0)
   */
  function vote(bytes32 _proposalId, int _vote) {
    internalVote(_proposalId, _vote, msg.sender);
  }

  /**
   * @dev voting function with owner functionality (can vote on behalf of someone else)
   * @param _proposalId id of the proposal
   * @param _vote yes (1) / no (-1) / abstain (0)
   * @param _voter will be voted with that voter's address
   */
  function ownerVote(bytes32 _proposalId, int _vote, address _voter) onlyOwner(_proposalId) returns(bool) {
    if (! parameters[proposals[_proposalId].paramsHash].allowOwner) {
      return false;
    }
    internalVote(_proposalId, _vote, _voter);
    return true;
  }

  /**
   * @dev Cancel the vote of the msg.sender: subtract the reputation amount from the votes
   * and delete the voter from the porposal struct
   * @param _proposalId id of the proposal
   */
  function cancelVote(bytes32 _proposalId) votableProposal(_proposalId) {
    Proposal storage proposal = proposals[_proposalId];

    Voter storage voter = proposal.voters[msg.sender];
    if (voter.vote == 1) {
        proposal.yes = (proposal.yes).sub(voter.reputation);
    }
    if (voter.vote == -1) {
        proposal.no = (proposal.no).sub(voter.reputation);
    }
    if (voter.vote == 0) {
        proposal.abstain = (proposal.abstain).sub(voter.reputation);
    }

    delete proposal.voters[msg.sender];
    LogCancelVoting(_proposalId, msg.sender);
  }

  /**
   * @dev check if the proposal has been decided, and if so, execute the proposal
   * @param _proposalId the id of the proposal
   * @return bool is the porposal has been executed or not?
   */
  // TODO: do we want to delete the vote from the proposals mapping?
  function executeProposal(bytes32 _proposalId) votableProposal(_proposalId) returns(bool) {
    Proposal memory proposal = proposals[_proposalId];

    uint totalReputation = parameters[proposal.paramsHash].reputationSystem.totalSupply();
    uint precReq = parameters[proposal.paramsHash].precReq;

    // "yes" was elected, executing with "yes"
    if (proposal.yes > totalReputation*precReq/100) {
      proposals[_proposalId].executed = true;
      LogExecuteProposal(_proposalId, 1);
      proposal.executable.execute(_proposalId, proposal.avatar, 1);
      return true;
    }
    // "no" was elected, executing with "no"
    if (proposal.no > totalReputation*precReq/100) {
      proposals[_proposalId].executed = true;
      LogExecuteProposal(_proposalId, -1);
      proposal.executable.execute(_proposalId, proposal.avatar, -1);
      return true;
    }
    return false;
  }

  /**
   * @dev voteInfo returns the vote and the amount of reputation of the user committed to this proposal
   * @param _proposalId the ID of the proposal
   * @param _voter the address of the voter
   * @return int[10] array that contains the vote's info:
   * amount of reputation committed by _voter to _proposalId, and the voters vote (1/-1/-0)
   */
  function voteInfo(bytes32 _proposalId, address _voter) constant returns(int[10]) {
    Voter memory voter = proposals[_proposalId].voters[_voter];
    return [voter.vote, int(voter.reputation), 0, 0, 0, 0, 0, 0, 0, 0];
  }

  /**
   * @dev proposalStatus returns the number of yes, no, and abstain and if the porposal is ended of a given porposal id
   * @param _proposalId the ID of the proposal
   * @return int[10] array that contains the porposal's info:
   * number of yes, no, and abstain, and if the voting for the porposal has ended
   */
  function proposalStatus(bytes32 _proposalId) constant returns(uint[10]) {
    Proposal memory proposal = proposals[_proposalId];
    uint ended = proposal.executed ? 1 : 0;

    return [proposal.yes, proposal.no, proposal.abstain, ended, 0, 0, 0, 0, 0, 0];
  }
}
